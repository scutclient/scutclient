#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h> 
#include <pcap.h>
#define PRINTINFO 1 
extern char *UserName;
extern char *Password;
extern char ipaddrinfo[16];
extern uint8_t Packet[255];
extern uint8_t	EthHeader[14]; // ethernet header
extern uint8_t checksum[23];
extern uint8_t BroadcastAddr[6]; // 广播MAC地址
extern uint8_t MultcastAddr[6]; // 多播MAC地址
extern uint8_t MAC[6];
extern size_t userlen,iplen,packetlen;
extern pcap_t *adhandle; 
typedef enum {REQUEST=1, RESPONSE=2, SUCCESS=3, FAILURE=4, H3CDATA=10} EAP_Code;
typedef enum {IDENTITY=1, NOTIFICATION=2, MD5=4, AVAILABLE=20, ALLOCATED=7} EAP_Type;;
void SendYoungStartPkt();
void SendYoungLogoffPkt();
void SendYoungResponseIdentity(const uint8_t request[]);
void SendYoungResponseMD5(const uint8_t request[]);

void SendYoungStartPkt()
{
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	// Fill Ethernet header
	memcpy(Packet, EthHeader,14);

	// EAPOL (4 Bytes)
	Packet[14] = 0x01;	// Version=1
	Packet[15] = 0x01;	// Type=Start
	Packet[16] = 0x00;// Length=0x0000
	Packet[17] = 0x00;

	for(packetlen=18;packetlen<=148;packetlen++)
	Packet[packetlen] =checksuminfo[packetlen-18];// Length=0x0000

#ifdef PRINTINFO
printf("\n*****************Start info***************************\n");
int m,n=0;
for(m=0;m<=packetlen-1;m++)
{
n++;
if(n==17)
{
printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif


//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}
/*
static
void LastSendStartPkt(pcap_t *adhandle)
{


	// Ethernet Header (14 Bytes)
	memcpy(Packet, MultcastAddr, 6);
	memcpy(Packet+6, MAC,   6);
	Packet[12] = 0x88;
	Packet[13] = 0x8e;

	// EAPOL (4 Bytes)
	Packet[14] = 0x01;	// Version=1
	Packet[15] = 0x01;	// Type=Start
	Packet[16] = Packet[17] =0x00;// Length=0x0000
	Packet[18] = Packet[19] =0x00;
	
//	memcpy(Packet, MultcastAddr, 6);
	
	pcap_sendpacket(adhandle, Packet, 19);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
	return;
}
*/

void SendYoungResponseIdentity(const uint8_t request[])
{
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	uint8_t ipinfo[100]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0x32,0x2e,0x31
	,0x2e,0x33,0x23,0x45,0x58,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00};
	memcpy(ipinfo, UserName, userlen);
	ipinfo[userlen]=0x23;
	ipinfo[1+userlen]=0x30;
	memcpy(ipinfo+2+userlen, ipaddrinfo, iplen);
	ipinfo[2+userlen+iplen]=0x23;
	ipinfo[3+userlen+iplen]=0x32;
	ipinfo[4+userlen+iplen]=0x2e;
	ipinfo[5+userlen+iplen]=0x31;
	ipinfo[6+userlen+iplen]=0x2e;
	ipinfo[7+userlen+iplen]=0x33;
	uint16_t eaplen;
	// Fill Ethernet header
	memcpy(Packet, EthHeader, 14);
	// 802,1X Authentication
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length
	// Extensible Authentication Protocol
	Packet[18] = /*(EAP_Code)*/ RESPONSE;	// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空			// Length
	Packet[22] = /*(EAP_Type)*/ IDENTITY;	// Type
	// Type-Data
	packetlen = 23;
	for(packetlen=23;packetlen<=30+userlen+iplen;packetlen++)
		Packet[packetlen] =ipinfo[packetlen-23];
	for(packetlen=31+userlen+iplen;packetlen<=162+userlen+iplen;packetlen++)
		Packet[packetlen] =checksuminfo[packetlen-31-userlen-iplen];
	// 补填前面留空的两处Length
	eaplen = htons(13+userlen+iplen);
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length
//			memcpy(Packet, MultcastAddr, 6);
	// 发送
	packetlen--;

#ifdef PRINTINFO
printf("\n***************Identity info****************************\n");
int m,n=0;
for(m=0;m<=packetlen-2;m++)
{
n++;
if(n==17)
{
printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif



//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}

void LastSendResponseIdentity(const uint8_t request[])
{
	int eaplen;
	memcpy(Packet, EthHeader, 14);
	// 802,1X Authentication
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length
	// Extensible Authentication Protocol
	Packet[18] = /*(EAP_Code)*/ RESPONSE;	// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空			// Length
	Packet[22] = /*(EAP_Type)*/ IDENTITY;	// Type
	// Type-Data
	packetlen = 23;
	Packet[23] = 0x68;
	Packet[24] = 0x6f;
	Packet[25] = 0x73;
	Packet[26] = 0x74;
	Packet[27] = 0x2f;
	Packet[28] = 0x46;
	Packet[29] = 0x6f;
	Packet[30] = 0x72;
	Packet[31] = 0x77;
	Packet[32] = 0x61;
	Packet[33] = 0x77;
	Packet[34] = 0x64;
	Packet[35] = 0x0;

	eaplen =htons(11);
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length
//Packet[17] =13+userlen+iplen;
//Packet[21] =13+userlen+iplen;
//	memcpy(Packet, MultcastAddr, 6);
	// 发送
	packetlen=35;

#ifdef PRINTINFO
printf("\n*******************Identity***********************\n");
int m,n=0;
for(m=0;m<=packetlen-2;m++)
{
n++;
if(n==17)
{
printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif



//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}

void SendYoungResponseMD5(const uint8_t request[])
{
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	uint8_t md5info[100]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0x32,0x2e,0x31
	,0x2e,0x33,0x23,0x45,0x58,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00};
	int k=0;
	memcpy(md5info, Password, 16);
	if(strlen(Password)<=16)
	for(k=strlen(Password);k<=15;k++)
	md5info[k] = 0x0;
	memcpy(md5info+16, UserName, userlen);
	md5info[17+userlen]=0x23;
	md5info[18+userlen]=0x30;
	memcpy(md5info+19+userlen, ipaddrinfo, iplen);
	md5info[19+userlen+iplen]=0x23;
	md5info[20+userlen+iplen]=0x32;
	md5info[21+userlen+iplen]=0x2e;
	md5info[22+userlen+iplen]=0x31;
	md5info[23+userlen+iplen]=0x2e;
	md5info[24+userlen+iplen]=0x33;
	md5info[25+userlen+iplen]=0x23;
	md5info[26+userlen+iplen]=0x45;
	md5info[27+userlen+iplen]=0x58;
	md5info[28+userlen+iplen]=0x54;
	md5info[16+userlen]=md5info[34+userlen];
	uint16_t eaplen;
	// Fill Ethernet header
	memcpy(Packet, EthHeader, 14);
	// 802,1X Authentication
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length

		// Extensible Authentication Protocol
		// {
	Packet[18] = /*(EAP_Code)*/ RESPONSE;// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空

	Packet[22] = /*(EAP_Type)*/ MD5;	// Type
	Packet[23] = 16;		// Value-Size: 16 Bytes
	for(packetlen=24;packetlen<=52+userlen+iplen;packetlen++)
		Packet[packetlen] =md5info[packetlen-24];
	for(;packetlen<=184+userlen+iplen;packetlen++)
		Packet[packetlen] =checksuminfo[packetlen-53-userlen-iplen];

	eaplen =htons(35+userlen+iplen);
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length
	packetlen--;

#ifdef PRINTINFO
printf("\n***************MD5 info******************************\n");
int m,n=0;
for(m=0;m<=packetlen-2;m++)
{
n++;
if(n==17)
{
printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif



//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}

void LastSendResponseMD5(const uint8_t request[])
{
	uint16_t eaplen;
	memcpy(Packet, EthHeader, 14);
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length

		// Extensible Authentication Protocol
		// {
	Packet[18] = /*(EAP_Code)*/ RESPONSE;// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空

	Packet[22] = /*(EAP_Type)*/ 0x03;	// Type
	Packet[23] = 0x19;		// Value-Size: 16 Bytes
	Packet[24] = 0;
//	memcpy(Packet, MultcastAddr, 6);
	eaplen =htons(6);
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length
	packetlen=24;

#ifdef PRINTINFO
printf("\n***************Last MD5 info******************************\n");
int m,n=0;
for(m=0;m<=packetlen-2;m++)
{
n++;
if(n==17)
{
printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif

//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}

void SendYoungLogoffPkt()
{
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	size_t packetlen;
	// Ethernet Header (14 Bytes)
	memcpy(Packet, EthHeader, 14);
	// EAPOL (4 Bytes)
	Packet[14] = 0x01;	// Version=1
	Packet[15] = 0x02;	// Type=Logoff
	Packet[16] = 0x00;// Length=0x0000
	Packet[17] = 0x00;
	for(packetlen=18;packetlen<=148;packetlen++)
	Packet[packetlen] =checksuminfo[packetlen-18];// Length=0x0000


//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}
