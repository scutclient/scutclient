#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h> 
#include <pcap.h>
//#define PRINTINFO 1  //不显示详细信息
extern char *UserName;
extern char *Password;
extern char ipaddrinfo[16];
extern uint8_t Packet[255];
extern uint8_t	EthHeader[14]; // ethernet header
extern uint8_t checksum[23];
extern uint8_t BroadcastAddr[6]; // 广播MAC地址
extern uint8_t MultcastAddr[6]; // 多播MAC地址
extern uint8_t MAC[6];
extern size_t userlen,iplen,packetlen;
extern pcap_t *adhandle; 
typedef enum {REQUEST=1, RESPONSE=2, SUCCESS=3, FAILURE=4, H3CDATA=10} EAP_Code;
typedef enum {IDENTITY=1, NOTIFICATION=2, MD5=4, AVAILABLE=20, ALLOCATED=7} EAP_Type;;
void SendYoungStartPkt();
void SendYoungLogoffPkt();
void SendYoungResponseIdentity(const uint8_t request[]);
void SendYoungResponseMD5(const uint8_t request[]);

void SendYoungStartPkt()
{
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	
	memcpy(checksuminfo, checksum,23);

	// Fill Ethernet header
	memcpy(Packet, EthHeader,14);

	// EAPOL (4 Bytes)
	Packet[14] = 0x01;	// Version=1
	Packet[15] = 0x01;	// Type=Start
	Packet[16] = 0x00;// Length=0x0000
	Packet[17] = 0x00;

	for(packetlen=18;packetlen<=148;packetlen++)
		Packet[packetlen] =checksuminfo[packetlen-18];// Length=0x0000

#ifdef PRINTINFO
printf("\n*****************Start info***************************\n");
int m,n=0;
for(m=0;m<=packetlen-1;m++)
{
n++;
if(n==17)
{
//printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif


//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}
/*
static
void LastSendStartPkt(pcap_t *adhandle)
{


	// Ethernet Header (14 Bytes)
	memcpy(Packet, MultcastAddr, 6);
	memcpy(Packet+6, MAC,   6);
	Packet[12] = 0x88;
	Packet[13] = 0x8e;

	// EAPOL (4 Bytes)
	Packet[14] = 0x01;	// Version=1
	Packet[15] = 0x01;	// Type=Start
	Packet[16] = Packet[17] =0x00;// Length=0x0000
	Packet[18] = Packet[19] =0x00;
	
//	memcpy(Packet, MultcastAddr, 6);
	
	pcap_sendpacket(adhandle, Packet, 19);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
	return;
}
*/

void SendYoungResponseIdentity(const uint8_t request[])
{
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);  // 填入functions.c的值     modified by 7forz 
	uint8_t ipinfo[100]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0x30,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0x32,0x2e,0x31
	,0x2e,0x35,0x23,0x45,0x58,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00};
	memcpy(ipinfo, UserName, userlen);
	ipinfo[userlen]=0x23;  //#
	ipinfo[1+userlen]=0x30;  //0
	memcpy(2+userlen+ipinfo, ipaddrinfo, iplen);
	ipinfo[2+userlen+iplen]=0x23;  //#
	ipinfo[3+userlen+iplen]=0x34;  //4
	ipinfo[4+userlen+iplen]=0x2e;  //.
	ipinfo[5+userlen+iplen]=0x31;  //1
	ipinfo[6+userlen+iplen]=0x2e;  //.   跟随版本号变化
	ipinfo[7+userlen+iplen]=0x35;  //5   modified by 7forz 
	ipinfo[8+userlen+iplen]=0x23;  //#
	uint16_t eaplen;
	// Fill Ethernet header
	memcpy(Packet, EthHeader, 14);
	// 802,1X Authentication
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length
	// Extensible Authentication Protocol
	Packet[18] = /*(EAP_Code)*/ RESPONSE;	// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空			// Length
	Packet[22] = /*(EAP_Type)*/ IDENTITY;	// Type
	// Type-Data
	packetlen = 23;
	for(packetlen=23;packetlen<=35+userlen+iplen;packetlen++)
		Packet[packetlen] =ipinfo[packetlen-23];  //从23到(35+12+14)=61
	
	/* 7forz   从Packet[23]开始是   用户名+#0+IP+#4.1.5#EXT  按我的来算是到从Packet[61] */
	
	//for(packetlen=31+userlen+iplen;packetlen<=162+userlen+iplen;packetlen++)   原来的2
	for(packetlen=36+userlen+iplen;packetlen<=166+userlen+iplen;packetlen++)  //从Packet[62]到Packet[192]共131项
		Packet[packetlen] =checksuminfo[packetlen-36-userlen-iplen];
	// 补填前面留空的两处Length
	//eaplen = htons(13+userlen+iplen);  //TODO:这里可能会有错
	eaplen = htons(13+5+userlen+iplen);  //这里加5试试看  7forz
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length
//			memcpy(Packet, MultcastAddr, 6);
	// 发送
	packetlen--;

#ifdef PRINTINFO
printf("\n***************Identity info****************************\n");
int m,n=0;
for(m=0;m<=packetlen-2;m++)
{
n++;
if(n==17)
{
//printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif



//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);
	
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}

void LastSendResponseIdentity(const uint8_t request[])
{
	int eaplen;
	memcpy(Packet, EthHeader, 14);
	// 802,1X Authentication
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length
	// Extensible Authentication Protocol
	Packet[18] = /*(EAP_Code)*/ RESPONSE;	// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空			// Length
	Packet[22] = /*(EAP_Type)*/ IDENTITY;	// Type
	// Type-Data
	packetlen = 23;
	Packet[23] = 0x68;
	Packet[24] = 0x6f;
	Packet[25] = 0x73;
	Packet[26] = 0x74;
	Packet[27] = 0x2f;
	Packet[28] = 0x46;
	Packet[29] = 0x6f;
	Packet[30] = 0x72;
	Packet[31] = 0x77;
	Packet[32] = 0x61;
	Packet[33] = 0x77;
	Packet[34] = 0x64;
	Packet[35] = 0x0;

	eaplen =htons(11);
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length
//Packet[17] =13+userlen+iplen;
//Packet[21] =13+userlen+iplen;
//	memcpy(Packet, MultcastAddr, 6);
	// 发送
	packetlen=35;

#ifdef PRINTINFO
printf("\n*******************Identity***********************\n");
int m,n=0;
for(m=0;m<=packetlen-2;m++)
{
n++;
if(n==17)
{
//printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif



//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}

void SendYoungResponseMD5(const uint8_t request[])
{
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	uint8_t md5info[100]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x23,0x32,0x2e,0x31
	,0x2e,0x33,0x23,0x45,0x58,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00};
	
	//格式：密码（16字节）+用户名+#0+IP+#4.1.5#EXT
	
	int k=0;
	memcpy(md5info, Password, 16);  //md5info[0~15] 密码（16字节）
	if(strlen(Password)<=16)
		for(k=strlen(Password);k<=15;k++)
			md5info[k] = 0x0;  //不足的填0x00
	
	memcpy(md5info+16, UserName, userlen);  //md5info[16~27] 用户名
	md5info[16+userlen]=0x23;  //#  md5info[28]
	md5info[17+userlen]=0x30;  //0  md5info[29]
	
	memcpy(md5info+18+userlen, ipaddrinfo, iplen);  //IP  md5info[30~43]
	md5info[18+userlen+iplen]=0x23;  //#
	md5info[19+userlen+iplen]=0x34;  //4
	md5info[20+userlen+iplen]=0x2e;  //.
	md5info[21+userlen+iplen]=0x31;  //1
	md5info[22+userlen+iplen]=0x2e;  //.
	md5info[23+userlen+iplen]=0x35;  //5
	md5info[24+userlen+iplen]=0x23;  //#
	md5info[25+userlen+iplen]=0x45;  //E
	md5info[26+userlen+iplen]=0x58;  //X
	md5info[27+userlen+iplen]=0x54;  //T  到这里是md5info[53]
	
	//md5info[16+userlen]=md5info[34+userlen];  //md5info[28]=md5info[46]=0x2e??  这是什么？
	uint16_t eaplen;
	

	
	// Fill Ethernet header
	memcpy(Packet, EthHeader, 14);
	// 802,1X Authentication
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length

		// Extensible Authentication Protocol
		// {
	Packet[18] = /*(EAP_Code)*/ RESPONSE;// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空  Length

	Packet[22] = /*(EAP_Type)*/ MD5;	// Type
	Packet[23] = 16;		// Value-Size: 16 Bytes   0x10
	
	
	
	for(packetlen=24;packetlen<=52+userlen+iplen;packetlen++)  //Packet[24~78]
		Packet[packetlen] = md5info[packetlen-24];
	
	for(;packetlen<=183+userlen+iplen;packetlen++)    //共Packet[209]
		//Packet[packetlen] = checksuminfo[packetlen-53-userlen-iplen];  modified by 7forz
		Packet[packetlen] = 0x00;
	
	eaplen =htons(35+userlen+iplen); //TODO:这里可能会有错
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length
	packetlen--;

#ifdef PRINTINFO
printf("\n***************MD5 info******************************\n");
int m,n=0;
for(m=0;m<=packetlen-2;m++)
{
n++;
if(n==17)
{
//printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif



//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}

void LastSendResponseMD5(const uint8_t request[])
{
	uint16_t eaplen;
	memcpy(Packet, EthHeader, 14);
	Packet[14] = 0x1;	// 802.1X Version 1
	Packet[15] = 0x0;	// Type=0 (EAP Packet)
	//Packet[16~17]留空	// Length

		// Extensible Authentication Protocol
		// {
	Packet[18] = /*(EAP_Code)*/ RESPONSE;// Code
	Packet[19] = request[19];		// ID
	//Packet[20~21]留空

	Packet[22] = /*(EAP_Type)*/ 0x03;	// Type
	Packet[23] = 0x19;		// Value-Size: 16 Bytes
	Packet[24] = 0;
//	memcpy(Packet, MultcastAddr, 6);
	eaplen =htons(6);
	memcpy(Packet+16, &eaplen, sizeof(eaplen));// Length
	memcpy(Packet+20, &eaplen, sizeof(eaplen));// Length
	packetlen=24;

#ifdef PRINTINFO
printf("\n***************Last MD5 info******************************\n");
int m,n=0;
for(m=0;m<=packetlen-2;m++)
{
n++;
if(n==17)
{
//printf("\n");
n=1;
}
printf("%02x ",Packet[m]);
}
printf("\n");
#endif

//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}

void SendYoungLogoffPkt()
{
	uint8_t checksuminfo[131]=
	{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x13,0x11,0x38,0x30,0x32,0x31,0x78
	,0x2e,0x65,0x78,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x37,0x35,0x30,0x30
	,0x00,0x00,0x13,0x11,0x00,0x28,0x1a,0x28,0x00,0x00,0x13,0x11,0x17,0x22,0x91,0x62
	,0x61,0x65,0x61,0x65,0x61,0x69,0x63,0x68,0x95,0x69,0x66,0x94,0x94,0x63,0x95,0x60
	,0x68,0x94,0x68,0x94,0x68,0x63,0x96,0x91,0x61,0x9a,0xa7,0x94,0x9f,0xab,0x00,0x00
	,0x13,0x11,0x18,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	,0x00,0x00,0x00};
	memcpy(checksuminfo, checksum,23);
	size_t packetlen;
	// Ethernet Header (14 Bytes)
	memcpy(Packet, EthHeader, 14);
	// EAPOL (4 Bytes)
	Packet[14] = 0x01;	// Version=1
	Packet[15] = 0x02;	// Type=Logoff
	Packet[16] = 0x00;// Length=0x0000
	Packet[17] = 0x00;
	for(packetlen=18;packetlen<=148;packetlen++)
	Packet[packetlen] =checksuminfo[packetlen-18];// Length=0x0000


//	const struct pcap_pkthdr *header;
//	const uint8_t	*captured;
//	pcap_next_ex(adhandle, &header, &captured);
//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	pcap_dump_flush((unsigned char *)dumpfile);

//	pcap_dump((unsigned char *)dumpfile, header, captured);
//	return;
}
